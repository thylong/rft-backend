// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: okrs.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteOkr = `-- name: DeleteOkr :exec
WITH deleted_krs AS (
    DELETE FROM okr_krs
    WHERE okr_krs.okr_id = $1
)
DELETE FROM okrs
WHERE okrs.id = $1
`

// Delete an okr by ID
func (q *Queries) DeleteOkr(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteOkr, id)
	return err
}

const getOkrByID = `-- name: GetOkrByID :one
SELECT 
    o.id AS okr_id, 
    o.name AS okr_name, 
    o.number AS okr_number, 
    o.year AS okr_year, 
    o.description AS okr_description,
    ARRAY_AGG(
        JSON_BUILD_OBJECT(
            'id', k.id,
            'name', k.name,
            'number', k.number,
            'year', k.year,
            'description', k.description
        )
    ) AS key_results
FROM okrs o
LEFT JOIN okr_krs k ON o.id = k.okr_id
WHERE o.id = $1
GROUP BY o.id
`

type GetOkrByIDRow struct {
	OkrID          pgtype.UUID `json:"okr_id"`
	OkrName        string      `json:"okr_name"`
	OkrNumber      int32       `json:"okr_number"`
	OkrYear        int32       `json:"okr_year"`
	OkrDescription string      `json:"okr_description"`
	KeyResults     interface{} `json:"key_results"`
}

// Get a single okr by ID
func (q *Queries) GetOkrByID(ctx context.Context, id pgtype.UUID) (GetOkrByIDRow, error) {
	row := q.db.QueryRow(ctx, getOkrByID, id)
	var i GetOkrByIDRow
	err := row.Scan(
		&i.OkrID,
		&i.OkrName,
		&i.OkrNumber,
		&i.OkrYear,
		&i.OkrDescription,
		&i.KeyResults,
	)
	return i, err
}

const getOkrs = `-- name: GetOkrs :many

SELECT 
    o.id AS okr_id, 
    o.name AS okr_name, 
    o.number AS okr_number, 
    o.year AS okr_year, 
    o.description AS okr_description,
    ARRAY_AGG(
        JSON_BUILD_OBJECT(
            'id', k.id,
            'name', k.name,
            'number', k.number,
            'year', k.year,
            'description', k.description
        )
    ) AS key_results
FROM okrs o
LEFT JOIN okr_krs k ON o.id = k.okr_id
GROUP BY o.id
LIMIT $1 OFFSET $2
`

type GetOkrsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetOkrsRow struct {
	OkrID          pgtype.UUID `json:"okr_id"`
	OkrName        string      `json:"okr_name"`
	OkrNumber      int32       `json:"okr_number"`
	OkrYear        int32       `json:"okr_year"`
	OkrDescription string      `json:"okr_description"`
	KeyResults     interface{} `json:"key_results"`
}

// okrs.sql
// Get okrs with pagination and optional search
func (q *Queries) GetOkrs(ctx context.Context, arg GetOkrsParams) ([]GetOkrsRow, error) {
	rows, err := q.db.Query(ctx, getOkrs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOkrsRow
	for rows.Next() {
		var i GetOkrsRow
		if err := rows.Scan(
			&i.OkrID,
			&i.OkrName,
			&i.OkrNumber,
			&i.OkrYear,
			&i.OkrDescription,
			&i.KeyResults,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOkrsCount = `-- name: GetOkrsCount :one
SELECT COUNT(*) FROM okrs
WHERE (LOWER(name) LIKE LOWER('%' || $1 || '%') OR $1 = '')
`

// Get total count for pagination
func (q *Queries) GetOkrsCount(ctx context.Context, dollar_1 pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, getOkrsCount, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const insertOkr = `-- name: InsertOkr :exec
WITH new_okr AS (
    INSERT INTO okrs (id, name, number, year, description)
    VALUES ($1, $2, $3, $4, $5)
    RETURNING id
),
expanded_krs AS (
    SELECT
        UNNEST($6::uuid[]) AS kr_id,
        UNNEST($7::text[]) AS kr_name,
        UNNEST($8::int[]) AS kr_number,
        UNNEST($9::int[]) AS kr_year,
        UNNEST($10::text[]) AS kr_description,
        (SELECT id FROM new_okr) AS okr_id
)
INSERT INTO okr_krs (id, okr_id, name, number, year, description)
SELECT kr_id, okr_id, kr_name, kr_number, kr_year, kr_description
FROM expanded_krs
`

type InsertOkrParams struct {
	ID          pgtype.UUID   `json:"id"`
	Name        string        `json:"name"`
	Number      int32         `json:"number"`
	Year        int32         `json:"year"`
	Description string        `json:"description"`
	Column6     []pgtype.UUID `json:"column_6"`
	Column7     []string      `json:"column_7"`
	Column8     []int32       `json:"column_8"`
	Column9     []int32       `json:"column_9"`
	Column10    []string      `json:"column_10"`
}

// Insert a new okr
func (q *Queries) InsertOkr(ctx context.Context, arg InsertOkrParams) error {
	_, err := q.db.Exec(ctx, insertOkr,
		arg.ID,
		arg.Name,
		arg.Number,
		arg.Year,
		arg.Description,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Column9,
		arg.Column10,
	)
	return err
}
