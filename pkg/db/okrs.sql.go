// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: okrs.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteOkr = `-- name: DeleteOkr :exec
WITH deleted_krs AS (
    DELETE FROM okr_krs
    WHERE okr_krs.okr_id = $1
)
DELETE FROM okrs
WHERE okrs.id = $1
`

// Delete an okr by ID
func (q *Queries) DeleteOkr(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteOkr, id)
	return err
}

const getOkrByID = `-- name: GetOkrByID :one
SELECT 
    o.id AS okr_id, 
    o.name AS okr_name, 
    o.number AS okr_number, 
    o.year AS okr_year, 
    o.description AS okr_description,
    ARRAY_AGG(
        JSON_BUILD_OBJECT(
            'id', k.id,
            'name', k.name,
            'number', k.number,
            'description', k.description,
            'sponsor', k.sponsor,
            'kpis', k.kpis,
            'scope', k.scope,
            'initiatives', k.initiatives
        )
    ) AS key_results
FROM okrs o
LEFT JOIN okr_krs k ON o.id = k.okr_id
WHERE o.id = $1
GROUP BY o.id
`

type GetOkrByIDRow struct {
	OkrID          pgtype.UUID `json:"okr_id"`
	OkrName        string      `json:"okr_name"`
	OkrNumber      int32       `json:"okr_number"`
	OkrYear        int32       `json:"okr_year"`
	OkrDescription string      `json:"okr_description"`
	KeyResults     interface{} `json:"key_results"`
}

// Get a single okr by ID
func (q *Queries) GetOkrByID(ctx context.Context, id pgtype.UUID) (GetOkrByIDRow, error) {
	row := q.db.QueryRow(ctx, getOkrByID, id)
	var i GetOkrByIDRow
	err := row.Scan(
		&i.OkrID,
		&i.OkrName,
		&i.OkrNumber,
		&i.OkrYear,
		&i.OkrDescription,
		&i.KeyResults,
	)
	return i, err
}

const getOkrs = `-- name: GetOkrs :many

SELECT 
    o.id AS okr_id, 
    o.name AS okr_name, 
    o.number AS okr_number, 
    o.year AS okr_year, 
    o.description AS okr_description,
    COALESCE(
        ARRAY_AGG(
            JSON_BUILD_OBJECT(
                'id', k.id,
                'name', k.name,
                'number', k.number,
                'description', k.description,
                'sponsor', k.sponsor,
                'kpis', k.kpis,
                'scope', k.scope,
                'initiatives', k.initiatives
            )
        ) FILTER (WHERE k.id IS NOT NULL), 
        '{}'::json[]
    ) AS key_results
FROM okrs o
LEFT JOIN okr_krs k ON o.id = k.okr_id
GROUP BY o.id, o.name, o.number, o.year, o.description
LIMIT $1 OFFSET $2
`

type GetOkrsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetOkrsRow struct {
	OkrID          pgtype.UUID `json:"okr_id"`
	OkrName        string      `json:"okr_name"`
	OkrNumber      int32       `json:"okr_number"`
	OkrYear        int32       `json:"okr_year"`
	OkrDescription string      `json:"okr_description"`
	KeyResults     interface{} `json:"key_results"`
}

// okrs.sql
// Get okrs with pagination and optional search
func (q *Queries) GetOkrs(ctx context.Context, arg GetOkrsParams) ([]GetOkrsRow, error) {
	rows, err := q.db.Query(ctx, getOkrs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOkrsRow
	for rows.Next() {
		var i GetOkrsRow
		if err := rows.Scan(
			&i.OkrID,
			&i.OkrName,
			&i.OkrNumber,
			&i.OkrYear,
			&i.OkrDescription,
			&i.KeyResults,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOkrsCount = `-- name: GetOkrsCount :one
SELECT COUNT(*) FROM okrs
WHERE (LOWER(name) LIKE LOWER('%' || $1 || '%') OR $1 = '')
`

// Get total count for pagination
func (q *Queries) GetOkrsCount(ctx context.Context, dollar_1 pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, getOkrsCount, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const insertKeyResult = `-- name: InsertKeyResult :one
INSERT INTO okr_krs (
    okr_id, 
    name, 
    number, 
    description, 
    sponsor, 
    kpis, 
    scope, 
    initiatives
)
VALUES 
    ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING 
    id, 
    okr_id, 
    name, 
    number, 
    description, 
    sponsor, 
    kpis, 
    scope, 
    initiatives
`

type InsertKeyResultParams struct {
	OkrID       pgtype.UUID `json:"okr_id"`
	Name        string      `json:"name"`
	Number      int32       `json:"number"`
	Description string      `json:"description"`
	Sponsor     string      `json:"sponsor"`
	Kpis        string      `json:"kpis"`
	Scope       string      `json:"scope"`
	Initiatives string      `json:"initiatives"`
}

// Insert a new key result
func (q *Queries) InsertKeyResult(ctx context.Context, arg InsertKeyResultParams) (OkrKr, error) {
	row := q.db.QueryRow(ctx, insertKeyResult,
		arg.OkrID,
		arg.Name,
		arg.Number,
		arg.Description,
		arg.Sponsor,
		arg.Kpis,
		arg.Scope,
		arg.Initiatives,
	)
	var i OkrKr
	err := row.Scan(
		&i.ID,
		&i.OkrID,
		&i.Name,
		&i.Number,
		&i.Description,
		&i.Sponsor,
		&i.Kpis,
		&i.Scope,
		&i.Initiatives,
	)
	return i, err
}

const insertOkr = `-- name: InsertOkr :one
WITH new_okr AS (
    INSERT INTO okrs (name, number, year, description)
    VALUES ($1, $2, $3, $4)
    RETURNING id, name, number, year, description
)
SELECT 
    o.id AS okr_id,
    o.name AS okr_name,
    o.number AS okr_number,
    o.year AS okr_year,
    o.description AS okr_description
FROM 
    new_okr o
`

type InsertOkrParams struct {
	Name        string `json:"name"`
	Number      int32  `json:"number"`
	Year        int32  `json:"year"`
	Description string `json:"description"`
}

type InsertOkrRow struct {
	OkrID          pgtype.UUID `json:"okr_id"`
	OkrName        string      `json:"okr_name"`
	OkrNumber      int32       `json:"okr_number"`
	OkrYear        int32       `json:"okr_year"`
	OkrDescription string      `json:"okr_description"`
}

// Insert a new okr
func (q *Queries) InsertOkr(ctx context.Context, arg InsertOkrParams) (InsertOkrRow, error) {
	row := q.db.QueryRow(ctx, insertOkr,
		arg.Name,
		arg.Number,
		arg.Year,
		arg.Description,
	)
	var i InsertOkrRow
	err := row.Scan(
		&i.OkrID,
		&i.OkrName,
		&i.OkrNumber,
		&i.OkrYear,
		&i.OkrDescription,
	)
	return i, err
}
